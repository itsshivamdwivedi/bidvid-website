"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-image-export-optimizer";
exports.ids = ["vendor-chunks/next-image-export-optimizer"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ var _excluded = [\n    \"src\",\n    \"priority\",\n    \"loading\",\n    \"className\",\n    \"width\",\n    \"height\",\n    \"onLoad\",\n    \"unoptimized\",\n    \"placeholder\",\n    \"basePath\",\n    \"alt\",\n    \"blurDataURL\",\n    \"style\",\n    \"onError\",\n    \"overrideSrc\"\n];\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\n\n\nvar splitFilePath = function splitFilePath(_ref) {\n    var _filePath$split$pop;\n    var filePath = _ref.filePath;\n    var filenameWithExtension = ((_filePath$split$pop = filePath.split(\"\\\\\").pop()) === null || _filePath$split$pop === void 0 ? void 0 : _filePath$split$pop.split(\"/\").pop()) || \"\";\n    var filePathWithoutFilename = filePath.split(filenameWithExtension).shift();\n    var fileExtension = filePath.split(\".\").pop();\n    var filenameWithoutExtension = filenameWithExtension.substring(0, filenameWithExtension.lastIndexOf(\".\")) || filenameWithExtension;\n    return {\n        path: filePathWithoutFilename,\n        filename: filenameWithoutExtension,\n        extension: fileExtension || \"\"\n    };\n};\nvar generateImageURL = function generateImageURL(src, width, basePath) {\n    var _correctedPath;\n    var isRemoteImage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var _splitFilePath = splitFilePath({\n        filePath: src\n    }), filename = _splitFilePath.filename, path = _splitFilePath.path, extension = _splitFilePath.extension;\n    var useWebp =  true ? \"true\" == \"true\" : 0;\n    if (![\n        \"JPG\",\n        \"JPEG\",\n        \"WEBP\",\n        \"PNG\",\n        \"AVIF\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        // The images has an unsupported extension\n        // We will return the src\n        return src;\n    }\n    // If the images are stored as WEBP by the package, then we should change\n    // the extension to WEBP to load them correctly\n    var processedExtension = extension;\n    if (useWebp && [\n        \"JPG\",\n        \"JPEG\",\n        \"PNG\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        processedExtension = \"WEBP\";\n    }\n    var correctedPath = path;\n    var lastChar = (_correctedPath = correctedPath) === null || _correctedPath === void 0 ? void 0 : _correctedPath.substr(-1); // Selects the last character\n    if (lastChar != \"/\") {\n        // If the last character is not a slash\n        correctedPath = correctedPath + \"/\"; // Append a slash to it.\n    }\n    var isStaticImage = src.includes(\"_next/static/media\");\n    if (basePath) {\n        if (basePath.endsWith(\"/\") && correctedPath && correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + correctedPath.slice(1);\n        } else if (!basePath.endsWith(\"/\") && correctedPath && !correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + \"/\" + correctedPath;\n        } else {\n            correctedPath = basePath + correctedPath;\n        }\n    }\n    var exportFolderName = \"nextImageExportOptimizer\" || 0;\n    var basePathPrefixForStaticImages = basePath ? basePath + \"/\" : \"\";\n    var generatedImageURL = \"\".concat(isStaticImage ? basePathPrefixForStaticImages : correctedPath).concat(exportFolderName, \"/\").concat(filename, \"-opt-\").concat(width, \".\").concat(processedExtension.toUpperCase());\n    // if the generatedImageURL is not starting with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && generatedImageURL.charAt(0) !== \"/\") {\n        generatedImageURL = \"/\" + generatedImageURL;\n    }\n    return generatedImageURL;\n};\n// Credits to https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\n// This is a hash function that is used to generate a hash from the image URL\nvar hashAlgorithm = function hashAlgorithm(str) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n    for(var i = 0, ch; i < str.length; i++){\n        ch = str.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 2654435761);\n        h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n    h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);\n    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n    h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\nfunction urlToFilename(url) {\n    try {\n        var parsedUrl = new URL(url);\n        var extension = parsedUrl.pathname.split(\".\").pop();\n        if (extension) {\n            return hashAlgorithm(url).toString().concat(\".\", extension);\n        }\n    } catch (error) {\n        console.error(\"Error parsing URL\", url, error);\n    }\n    return hashAlgorithm(url).toString();\n}\nvar imageURLForRemoteImage = function imageURLForRemoteImage(_ref2) {\n    var src = _ref2.src, width = _ref2.width, basePath = _ref2.basePath;\n    var encodedSrc = urlToFilename(src);\n    return generateImageURL(encodedSrc, width, basePath, true);\n};\nvar optimizedLoader = function optimizedLoader(_ref3) {\n    var src = _ref3.src, width = _ref3.width, basePath = _ref3.basePath;\n    var isStaticImage = _typeof(src) === \"object\";\n    var _src = isStaticImage ? src.src : src;\n    var originalImageWidth = isStaticImage && src.width || undefined;\n    // if it is a static image, we can use the width of the original image to generate a reduced srcset that returns\n    // the same image url for widths that are larger than the original image\n    if (isStaticImage && originalImageWidth && width > originalImageWidth) {\n        var _process$env$__NEXT_I, _process$env$__NEXT_I2;\n        var deviceSizes = (((_process$env$__NEXT_I = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}) === null || _process$env$__NEXT_I === void 0 ? void 0 : _process$env$__NEXT_I.deviceSizes) || [\n            640,\n            750,\n            828,\n            1080,\n            1200,\n            1920,\n            2048,\n            3840\n        ]).map(Number);\n        var imageSizes = (((_process$env$__NEXT_I2 = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}) === null || _process$env$__NEXT_I2 === void 0 ? void 0 : _process$env$__NEXT_I2.imageSizes) || [\n            16,\n            32,\n            48,\n            64,\n            96,\n            128,\n            256,\n            384\n        ]).map(Number);\n        var allSizes = [].concat(_toConsumableArray(deviceSizes), _toConsumableArray(imageSizes));\n        allSizes = allSizes.filter(function(v, i, a) {\n            return a.indexOf(v) === i;\n        });\n        allSizes.sort(function(a, b) {\n            return a - b;\n        });\n        // only use the width if it is smaller or equal to the next size in the allSizes array\n        var nextLargestSize = null;\n        for(var i = 0; i < allSizes.length; i++){\n            if (Number(allSizes[i]) >= originalImageWidth && (nextLargestSize === null || Number(allSizes[i]) < nextLargestSize)) {\n                nextLargestSize = Number(allSizes[i]);\n            }\n        }\n        if (nextLargestSize !== null) {\n            return generateImageURL(_src, nextLargestSize, basePath);\n        }\n    }\n    // Check if the image is a remote image (starts with http or https)\n    if (_src.startsWith(\"http\")) {\n        return imageURLForRemoteImage({\n            src: _src,\n            width: width,\n            basePath: basePath\n        });\n    }\n    return generateImageURL(_src, width, basePath);\n};\nvar fallbackLoader = function fallbackLoader(_ref4) {\n    var src = _ref4.src;\n    var _src = _typeof(src) === \"object\" ? src.src : src;\n    var isRemoteImage = _src.startsWith(\"http\");\n    // if the _src does not start with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && _src.charAt(0) !== \"/\") {\n        _src = \"/\" + _src;\n    }\n    return _src;\n};\nvar ExportedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(_ref5, ref) {\n    var src = _ref5.src, _ref5$priority = _ref5.priority, priority = _ref5$priority === void 0 ? false : _ref5$priority, loading = _ref5.loading, className = _ref5.className, width = _ref5.width, height = _ref5.height, _onLoad = _ref5.onLoad, unoptimized = _ref5.unoptimized, _ref5$placeholder = _ref5.placeholder, placeholder = _ref5$placeholder === void 0 ? \"blur\" : _ref5$placeholder, _ref5$basePath = _ref5.basePath, basePath = _ref5$basePath === void 0 ? \"\" : _ref5$basePath, _ref5$alt = _ref5.alt, alt = _ref5$alt === void 0 ? \"\" : _ref5$alt, blurDataURL = _ref5.blurDataURL, style = _ref5.style, _onError = _ref5.onError, overrideSrc = _ref5.overrideSrc, rest = _objectWithoutProperties(_ref5, _excluded);\n    var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), imageError = _useState[0], setImageError = _useState[1];\n    var automaticallyCalculatedBlurDataURL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        if (blurDataURL) {\n            // use the user provided blurDataURL if present\n            return blurDataURL;\n        }\n        // check if the src is specified as a local file -> then it is an object\n        var isStaticImage = _typeof(src) === \"object\";\n        var _src = isStaticImage ? src.src : src;\n        if (unoptimized === true) {\n            // return the src image when unoptimized\n            return _src;\n        }\n        // Check if the image is a remote image (starts with http or https)\n        if (_src.startsWith(\"http\")) {\n            return imageURLForRemoteImage({\n                src: _src,\n                width: 10,\n                basePath: basePath\n            });\n        }\n        // otherwise use the generated image of 10px width as a blurDataURL\n        return generateImageURL(_src, 10, basePath);\n    }, [\n        blurDataURL,\n        src,\n        unoptimized,\n        basePath\n    ]);\n    // check if the src is a SVG image -> then we should not use the blurDataURL and use unoptimized\n    var isSVG = _typeof(src) === \"object\" ? src.src.endsWith(\".svg\") : src.endsWith(\".svg\");\n    var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), blurComplete = _useState2[0], setBlurComplete = _useState2[1];\n    // Currently, we have to handle the blurDataURL ourselves as the new Image component\n    // is expecting a base64 encoded string, but the generated blurDataURL is a normal URL\n    var blurStyle = placeholder === \"blur\" && !isSVG && automaticallyCalculatedBlurDataURL && automaticallyCalculatedBlurDataURL.startsWith(\"/\") && !blurComplete ? {\n        backgroundSize: (style === null || style === void 0 ? void 0 : style.objectFit) || \"cover\",\n        backgroundPosition: (style === null || style === void 0 ? void 0 : style.objectPosition) || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: 'url(\"'.concat(automaticallyCalculatedBlurDataURL, '\")')\n    } : undefined;\n    var isStaticImage = _typeof(src) === \"object\";\n    var _src = isStaticImage ? src.src : src;\n    if (basePath && !isStaticImage && _src.startsWith(\"/\")) {\n        _src = basePath + _src;\n    }\n    if (basePath && !isStaticImage && !_src.startsWith(\"/\")) {\n        _src = basePath + \"/\" + _src;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(next_image__WEBPACK_IMPORTED_MODULE_0__[\"default\"], _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n        ref: ref,\n        alt: alt\n    }, rest), width && {\n        width: width\n    }), height && {\n        height: height\n    }), loading && {\n        loading: loading\n    }), className && {\n        className: className\n    }), _onLoad && {\n        onLoad: _onLoad\n    }), overrideSrc && {\n        overrideSrc: overrideSrc\n    }), placeholder && {\n        placeholder: blurStyle || blurComplete ? \"empty\" : placeholder\n    }), unoptimized && {\n        unoptimized: unoptimized\n    }), priority && {\n        priority: priority\n    }), isSVG && {\n        unoptimized: true\n    }), {}, {\n        style: _objectSpread(_objectSpread({}, style), blurStyle),\n        loader: imageError || unoptimized === true ? function() {\n            return fallbackLoader({\n                src: overrideSrc || src\n            });\n        } : function(e) {\n            return optimizedLoader({\n                src: src,\n                width: e.width,\n                basePath: basePath\n            });\n        },\n        blurDataURL: automaticallyCalculatedBlurDataURL,\n        onError: function onError(error) {\n            setImageError(true);\n            setBlurComplete(true);\n            // execute the onError function if provided\n            _onError && _onError(error);\n        },\n        onLoad: function onLoad(e) {\n            // for some configurations, the onError handler is not called on an error occurrence\n            // so we need to check if the image is loaded correctly\n            var target = e.target;\n            if (target.naturalWidth === 0) {\n                // Broken image, fall back to unoptimized (meaning the original image src)\n                setImageError(true);\n            }\n            setBlurComplete(true);\n            // execute the onLoad callback if present\n            _onLoad && _onLoad(e);\n        },\n        src: isStaticImage ? src : _src\n    }));\n});\nExportedImage.displayName = \"ExportedImage\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExportedImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzZEQUFhLElBQUFBLFlBQUE7SUFBQTtJQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7Q0FBQTtBQUFBLFNBQUFDLFFBQUFDLENBQUEsRUFBQUMsQ0FBQTtJQUFBLElBQUFDLElBQUFDLE9BQUFDLElBQUEsQ0FBQUo7SUFBQSxJQUFBRyxPQUFBRSxxQkFBQTtRQUFBLElBQUFDLElBQUFILE9BQUFFLHFCQUFBLENBQUFMO1FBQUFDLEtBQUFLLENBQUFBLElBQUFBLEVBQUFDLE1BQUEsVUFBQU4sQ0FBQTtZQUFBLE9BQUFFLE9BQUFLLHdCQUFBLENBQUFSLEdBQUFDLEdBQUFRLFVBQUE7UUFBQSxLQUFBUCxFQUFBUSxJQUFBLENBQUFDLEtBQUEsQ0FBQVQsR0FBQUk7SUFBQTtJQUFBLE9BQUFKO0FBQUE7QUFBQSxTQUFBVSxjQUFBWixDQUFBO0lBQUEsUUFBQUMsSUFBQSxHQUFBQSxJQUFBWSxVQUFBQyxNQUFBLEVBQUFiLElBQUE7UUFBQSxJQUFBQyxJQUFBLFFBQUFXLFNBQUEsQ0FBQVosRUFBQSxHQUFBWSxTQUFBLENBQUFaLEVBQUE7UUFBQUEsSUFBQSxJQUFBRixRQUFBSSxPQUFBRCxJQUFBLElBQUFhLE9BQUEsVUFBQWQsQ0FBQTtZQUFBZSxnQkFBQWhCLEdBQUFDLEdBQUFDLENBQUEsQ0FBQUQsRUFBQTtRQUFBLEtBQUFFLE9BQUFjLHlCQUFBLEdBQUFkLE9BQUFlLGdCQUFBLENBQUFsQixHQUFBRyxPQUFBYyx5QkFBQSxDQUFBZixNQUFBSCxRQUFBSSxPQUFBRCxJQUFBYSxPQUFBLFVBQUFkLENBQUE7WUFBQUUsT0FBQWdCLGNBQUEsQ0FBQW5CLEdBQUFDLEdBQUFFLE9BQUFLLHdCQUFBLENBQUFOLEdBQUFEO1FBQUE7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QUFBO0lBQVksSUFBUUwsWUFBWTtRQUFFQSxVQUFBQTtJQUFTLElBQVFvQixTQUFTO1FBQUVmLGFBQWE7SUFBSyxJQUFDO1FBQUdPLE9BQUtoSyxjQUFBQSxjQUFBLElBQU9nSyxRQUFVWTtRQUFhUSxRQUFRZixjQUFjWixnQkFBZ0IsT0FDaEw7WUFBQSxPQUFNWCxlQUFlO2dCQUFFNUQsS0FBS2dGLGVBQWVoRjtZQUFJO1FBQUUsSUFDakQsU0FBQzlGLENBQUM7WUFBQSxPQUFLMEksZ0JBQWdCO2dCQUFFNUMsS0FBQUE7Z0JBQUtDLE9BQU8vRixFQUFFK0YsS0FBSztnQkFBRUMsVUFBQUE7WUFBUztRQUFFO1FBQUUyRSxhQUFhUTtRQUFvQ04sU0FBUyxTQUFBQSxRQUFDeEMsS0FBSztZQUM3SDZDLGNBQWM7WUFDZEssZ0JBQWdCO1lBQ2hCO1lBQ0FWLFlBQVdBLFNBQVF4QztRQUN2QjtRQUFHK0IsUUFBUSxTQUFBQSxPQUFDcEssQ0FBQztZQUNUO1lBQ0E7WUFDQSxJQUFNMkMsU0FBUzNDLEVBQUUyQyxNQUFNO1lBQ3ZCLElBQUlBLE9BQU9zSixZQUFZLEtBQUssR0FBRztnQkFDM0I7Z0JBQ0FmLGNBQWM7WUFDbEI7WUFDQUssZ0JBQWdCO1lBQ2hCO1lBQ0FuQixXQUFVQSxRQUFPcEs7UUFDckI7UUFBRzhGLEtBQUtnQixnQkFBZ0JoQixNQUFNOEM7SUFBSTtBQUMxQztBQUNBZ0IsY0FBY3NDLFdBQVcsR0FBRztBQUM1QixpRUFBZXRDLGFBQWFBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWR2aWQtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9uZXh0LWltYWdlLWV4cG9ydC1vcHRpbWl6ZXIvZGlzdC9FeHBvcnRlZEltYWdlLmpzP2VmMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIjtcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3Qgc3BsaXRGaWxlUGF0aCA9ICh7IGZpbGVQYXRoIH0pID0+IHtcbiAgICBjb25zdCBmaWxlbmFtZVdpdGhFeHRlbnNpb24gPSBmaWxlUGF0aC5zcGxpdChcIlxcXFxcIikucG9wKCk/LnNwbGl0KFwiL1wiKS5wb3AoKSB8fCBcIlwiO1xuICAgIGNvbnN0IGZpbGVQYXRoV2l0aG91dEZpbGVuYW1lID0gZmlsZVBhdGguc3BsaXQoZmlsZW5hbWVXaXRoRXh0ZW5zaW9uKS5zaGlmdCgpO1xuICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBmaWxlUGF0aC5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgY29uc3QgZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uID0gZmlsZW5hbWVXaXRoRXh0ZW5zaW9uLnN1YnN0cmluZygwLCBmaWxlbmFtZVdpdGhFeHRlbnNpb24ubGFzdEluZGV4T2YoXCIuXCIpKSB8fCBmaWxlbmFtZVdpdGhFeHRlbnNpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogZmlsZVBhdGhXaXRob3V0RmlsZW5hbWUsXG4gICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgIGV4dGVuc2lvbjogZmlsZUV4dGVuc2lvbiB8fCBcIlwiLFxuICAgIH07XG59O1xuY29uc3QgZ2VuZXJhdGVJbWFnZVVSTCA9IChzcmMsIHdpZHRoLCBiYXNlUGF0aCwgaXNSZW1vdGVJbWFnZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyBmaWxlbmFtZSwgcGF0aCwgZXh0ZW5zaW9uIH0gPSBzcGxpdEZpbGVQYXRoKHsgZmlsZVBhdGg6IHNyYyB9KTtcbiAgICBjb25zdCB1c2VXZWJwID0gcHJvY2Vzcy5lbnYubmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX3N0b3JlUGljdHVyZXNJbldFQlAgIT0gdW5kZWZpbmVkXG4gICAgICAgID8gcHJvY2Vzcy5lbnYubmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX3N0b3JlUGljdHVyZXNJbldFQlAgPT0gXCJ0cnVlXCJcbiAgICAgICAgOiB0cnVlO1xuICAgIGlmICghW1wiSlBHXCIsIFwiSlBFR1wiLCBcIldFQlBcIiwgXCJQTkdcIiwgXCJBVklGXCIsIFwiR0lGXCJdLmluY2x1ZGVzKGV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAvLyBUaGUgaW1hZ2VzIGhhcyBhbiB1bnN1cHBvcnRlZCBleHRlbnNpb25cbiAgICAgICAgLy8gV2Ugd2lsbCByZXR1cm4gdGhlIHNyY1xuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgaW1hZ2VzIGFyZSBzdG9yZWQgYXMgV0VCUCBieSB0aGUgcGFja2FnZSwgdGhlbiB3ZSBzaG91bGQgY2hhbmdlXG4gICAgLy8gdGhlIGV4dGVuc2lvbiB0byBXRUJQIHRvIGxvYWQgdGhlbSBjb3JyZWN0bHlcbiAgICBsZXQgcHJvY2Vzc2VkRXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuICAgIGlmICh1c2VXZWJwICYmXG4gICAgICAgIFtcIkpQR1wiLCBcIkpQRUdcIiwgXCJQTkdcIiwgXCJHSUZcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgIHByb2Nlc3NlZEV4dGVuc2lvbiA9IFwiV0VCUFwiO1xuICAgIH1cbiAgICBsZXQgY29ycmVjdGVkUGF0aCA9IHBhdGg7XG4gICAgY29uc3QgbGFzdENoYXIgPSBjb3JyZWN0ZWRQYXRoPy5zdWJzdHIoLTEpOyAvLyBTZWxlY3RzIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgIGlmIChsYXN0Q2hhciAhPSBcIi9cIikge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgbm90IGEgc2xhc2hcbiAgICAgICAgY29ycmVjdGVkUGF0aCA9IGNvcnJlY3RlZFBhdGggKyBcIi9cIjsgLy8gQXBwZW5kIGEgc2xhc2ggdG8gaXQuXG4gICAgfVxuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSBzcmMuaW5jbHVkZXMoXCJfbmV4dC9zdGF0aWMvbWVkaWFcIik7XG4gICAgaWYgKGJhc2VQYXRoKSB7XG4gICAgICAgIGlmIChiYXNlUGF0aC5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggJiZcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIGNvcnJlY3RlZFBhdGguc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWJhc2VQYXRoLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgICAgICAgICAgY29ycmVjdGVkUGF0aCAmJlxuICAgICAgICAgICAgIWNvcnJlY3RlZFBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIFwiL1wiICsgY29ycmVjdGVkUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIGNvcnJlY3RlZFBhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwb3J0Rm9sZGVyTmFtZSA9IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9leHBvcnRGb2xkZXJOYW1lIHx8XG4gICAgICAgIFwibmV4dEltYWdlRXhwb3J0T3B0aW1pemVyXCI7XG4gICAgY29uc3QgYmFzZVBhdGhQcmVmaXhGb3JTdGF0aWNJbWFnZXMgPSBiYXNlUGF0aCA/IGJhc2VQYXRoICsgXCIvXCIgOiBcIlwiO1xuICAgIGxldCBnZW5lcmF0ZWRJbWFnZVVSTCA9IGAke2lzU3RhdGljSW1hZ2UgPyBiYXNlUGF0aFByZWZpeEZvclN0YXRpY0ltYWdlcyA6IGNvcnJlY3RlZFBhdGh9JHtleHBvcnRGb2xkZXJOYW1lfS8ke2ZpbGVuYW1lfS1vcHQtJHt3aWR0aH0uJHtwcm9jZXNzZWRFeHRlbnNpb24udG9VcHBlckNhc2UoKX1gO1xuICAgIC8vIGlmIHRoZSBnZW5lcmF0ZWRJbWFnZVVSTCBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIHNsYXNoLCB0aGVuIHdlIGFkZCBvbmUgYXMgbG9uZyBhcyBpdCBpcyBub3QgYSByZW1vdGUgaW1hZ2VcbiAgICBpZiAoIWlzUmVtb3RlSW1hZ2UgJiYgZ2VuZXJhdGVkSW1hZ2VVUkwuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZVVSTCA9IFwiL1wiICsgZ2VuZXJhdGVkSW1hZ2VVUkw7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZVVSTDtcbn07XG4vLyBDcmVkaXRzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9icnljL2NvZGUvYmxvYi9tYXN0ZXIvanNoYXNoL2V4cGVyaW1lbnRhbC9jeXJiNTMuanNcbi8vIFRoaXMgaXMgYSBoYXNoIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBnZW5lcmF0ZSBhIGhhc2ggZnJvbSB0aGUgaW1hZ2UgVVJMXG5jb25zdCBoYXNoQWxnb3JpdGhtID0gKHN0ciwgc2VlZCA9IDApID0+IHtcbiAgICBsZXQgaDEgPSAweGRlYWRiZWVmIF4gc2VlZCwgaDIgPSAweDQxYzZjZTU3IF4gc2VlZDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2g7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaDEgPSBNYXRoLmltdWwoaDEgXiBjaCwgMjY1NDQzNTc2MSk7XG4gICAgICAgIGgyID0gTWF0aC5pbXVsKGgyIF4gY2gsIDE1OTczMzQ2NzcpO1xuICAgIH1cbiAgICBoMSA9IE1hdGguaW11bChoMSBeIChoMSA+Pj4gMTYpLCAyMjQ2ODIyNTA3KTtcbiAgICBoMSBePSBNYXRoLmltdWwoaDIgXiAoaDIgPj4+IDEzKSwgMzI2NjQ4OTkwOSk7XG4gICAgaDIgPSBNYXRoLmltdWwoaDIgXiAoaDIgPj4+IDE2KSwgMjI0NjgyMjUwNyk7XG4gICAgaDIgXj0gTWF0aC5pbXVsKGgxIF4gKGgxID4+PiAxMyksIDMyNjY0ODk5MDkpO1xuICAgIHJldHVybiA0Mjk0OTY3Mjk2ICogKDIwOTcxNTEgJiBoMikgKyAoaDEgPj4+IDApO1xufTtcbmZ1bmN0aW9uIHVybFRvRmlsZW5hbWUodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBwYXJzZWRVcmwucGF0aG5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzaEFsZ29yaXRobSh1cmwpLnRvU3RyaW5nKCkuY29uY2F0KFwiLlwiLCBleHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBVUkxcIiwgdXJsLCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBoYXNoQWxnb3JpdGhtKHVybCkudG9TdHJpbmcoKTtcbn1cbmNvbnN0IGltYWdlVVJMRm9yUmVtb3RlSW1hZ2UgPSAoeyBzcmMsIHdpZHRoLCBiYXNlUGF0aCwgfSkgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRTcmMgPSB1cmxUb0ZpbGVuYW1lKHNyYyk7XG4gICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoZW5jb2RlZFNyYywgd2lkdGgsIGJhc2VQYXRoLCB0cnVlKTtcbn07XG5jb25zdCBvcHRpbWl6ZWRMb2FkZXIgPSAoeyBzcmMsIHdpZHRoLCBiYXNlUGF0aCwgfSkgPT4ge1xuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgIGNvbnN0IF9zcmMgPSBpc1N0YXRpY0ltYWdlID8gc3JjLnNyYyA6IHNyYztcbiAgICBjb25zdCBvcmlnaW5hbEltYWdlV2lkdGggPSAoaXNTdGF0aWNJbWFnZSAmJiBzcmMud2lkdGgpIHx8IHVuZGVmaW5lZDtcbiAgICAvLyBpZiBpdCBpcyBhIHN0YXRpYyBpbWFnZSwgd2UgY2FuIHVzZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIGltYWdlIHRvIGdlbmVyYXRlIGEgcmVkdWNlZCBzcmNzZXQgdGhhdCByZXR1cm5zXG4gICAgLy8gdGhlIHNhbWUgaW1hZ2UgdXJsIGZvciB3aWR0aHMgdGhhdCBhcmUgbGFyZ2VyIHRoYW4gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgaWYgKGlzU3RhdGljSW1hZ2UgJiYgb3JpZ2luYWxJbWFnZVdpZHRoICYmIHdpZHRoID4gb3JpZ2luYWxJbWFnZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGRldmljZVNpemVzID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTPy5kZXZpY2VTaXplcyB8fCBbXG4gICAgICAgICAgICA2NDAsIDc1MCwgODI4LCAxMDgwLCAxMjAwLCAxOTIwLCAyMDQ4LCAzODQwLFxuICAgICAgICBdKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgY29uc3QgaW1hZ2VTaXplcyA9IChwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUz8uaW1hZ2VTaXplcyB8fCBbXG4gICAgICAgICAgICAxNiwgMzIsIDQ4LCA2NCwgOTYsIDEyOCwgMjU2LCAzODQsXG4gICAgICAgIF0pLm1hcChOdW1iZXIpO1xuICAgICAgICBsZXQgYWxsU2l6ZXMgPSBbLi4uZGV2aWNlU2l6ZXMsIC4uLmltYWdlU2l6ZXNdO1xuICAgICAgICBhbGxTaXplcyA9IGFsbFNpemVzLmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKTtcbiAgICAgICAgYWxsU2l6ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAvLyBvbmx5IHVzZSB0aGUgd2lkdGggaWYgaXQgaXMgc21hbGxlciBvciBlcXVhbCB0byB0aGUgbmV4dCBzaXplIGluIHRoZSBhbGxTaXplcyBhcnJheVxuICAgICAgICBsZXQgbmV4dExhcmdlc3RTaXplID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxTaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKE51bWJlcihhbGxTaXplc1tpXSkgPj0gb3JpZ2luYWxJbWFnZVdpZHRoICYmXG4gICAgICAgICAgICAgICAgKG5leHRMYXJnZXN0U2l6ZSA9PT0gbnVsbCB8fCBOdW1iZXIoYWxsU2l6ZXNbaV0pIDwgbmV4dExhcmdlc3RTaXplKSkge1xuICAgICAgICAgICAgICAgIG5leHRMYXJnZXN0U2l6ZSA9IE51bWJlcihhbGxTaXplc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRMYXJnZXN0U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoX3NyYywgbmV4dExhcmdlc3RTaXplLCBiYXNlUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGltYWdlIGlzIGEgcmVtb3RlIGltYWdlIChzdGFydHMgd2l0aCBodHRwIG9yIGh0dHBzKVxuICAgIGlmIChfc3JjLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgIHJldHVybiBpbWFnZVVSTEZvclJlbW90ZUltYWdlKHsgc3JjOiBfc3JjLCB3aWR0aCwgYmFzZVBhdGggfSk7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIHdpZHRoLCBiYXNlUGF0aCk7XG59O1xuY29uc3QgZmFsbGJhY2tMb2FkZXIgPSAoeyBzcmMgfSkgPT4ge1xuICAgIGxldCBfc3JjID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiA/IHNyYy5zcmMgOiBzcmM7XG4gICAgY29uc3QgaXNSZW1vdGVJbWFnZSA9IF9zcmMuc3RhcnRzV2l0aChcImh0dHBcIik7XG4gICAgLy8gaWYgdGhlIF9zcmMgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHNsYXNoLCB0aGVuIHdlIGFkZCBvbmUgYXMgbG9uZyBhcyBpdCBpcyBub3QgYSByZW1vdGUgaW1hZ2VcbiAgICBpZiAoIWlzUmVtb3RlSW1hZ2UgJiYgX3NyYy5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIF9zcmMgPSBcIi9cIiArIF9zcmM7XG4gICAgfVxuICAgIHJldHVybiBfc3JjO1xufTtcbmNvbnN0IEV4cG9ydGVkSW1hZ2UgPSBmb3J3YXJkUmVmKCh7IHNyYywgcHJpb3JpdHkgPSBmYWxzZSwgbG9hZGluZywgY2xhc3NOYW1lLCB3aWR0aCwgaGVpZ2h0LCBvbkxvYWQsIHVub3B0aW1pemVkLCBwbGFjZWhvbGRlciA9IFwiYmx1clwiLCBiYXNlUGF0aCA9IFwiXCIsIGFsdCA9IFwiXCIsIGJsdXJEYXRhVVJMLCBzdHlsZSwgb25FcnJvciwgb3ZlcnJpZGVTcmMsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgW2ltYWdlRXJyb3IsIHNldEltYWdlRXJyb3JdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGJsdXJEYXRhVVJMKSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIHVzZXIgcHJvdmlkZWQgYmx1ckRhdGFVUkwgaWYgcHJlc2VudFxuICAgICAgICAgICAgcmV0dXJuIGJsdXJEYXRhVVJMO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzcmMgaXMgc3BlY2lmaWVkIGFzIGEgbG9jYWwgZmlsZSAtPiB0aGVuIGl0IGlzIGFuIG9iamVjdFxuICAgICAgICBjb25zdCBpc1N0YXRpY0ltYWdlID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgbGV0IF9zcmMgPSBpc1N0YXRpY0ltYWdlID8gc3JjLnNyYyA6IHNyYztcbiAgICAgICAgaWYgKHVub3B0aW1pemVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIHNyYyBpbWFnZSB3aGVuIHVub3B0aW1pemVkXG4gICAgICAgICAgICByZXR1cm4gX3NyYztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW1hZ2UgaXMgYSByZW1vdGUgaW1hZ2UgKHN0YXJ0cyB3aXRoIGh0dHAgb3IgaHR0cHMpXG4gICAgICAgIGlmIChfc3JjLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSh7IHNyYzogX3NyYywgd2lkdGg6IDEwLCBiYXNlUGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBnZW5lcmF0ZWQgaW1hZ2Ugb2YgMTBweCB3aWR0aCBhcyBhIGJsdXJEYXRhVVJMXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIDEwLCBiYXNlUGF0aCk7XG4gICAgfSwgW2JsdXJEYXRhVVJMLCBzcmMsIHVub3B0aW1pemVkLCBiYXNlUGF0aF0pO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBzcmMgaXMgYSBTVkcgaW1hZ2UgLT4gdGhlbiB3ZSBzaG91bGQgbm90IHVzZSB0aGUgYmx1ckRhdGFVUkwgYW5kIHVzZSB1bm9wdGltaXplZFxuICAgIGNvbnN0IGlzU1ZHID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiA/IHNyYy5zcmMuZW5kc1dpdGgoXCIuc3ZnXCIpIDogc3JjLmVuZHNXaXRoKFwiLnN2Z1wiKTtcbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0byBoYW5kbGUgdGhlIGJsdXJEYXRhVVJMIG91cnNlbHZlcyBhcyB0aGUgbmV3IEltYWdlIGNvbXBvbmVudFxuICAgIC8vIGlzIGV4cGVjdGluZyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZywgYnV0IHRoZSBnZW5lcmF0ZWQgYmx1ckRhdGFVUkwgaXMgYSBub3JtYWwgVVJMXG4gICAgY29uc3QgYmx1clN0eWxlID0gcGxhY2Vob2xkZXIgPT09IFwiYmx1clwiICYmXG4gICAgICAgICFpc1NWRyAmJlxuICAgICAgICBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMICYmXG4gICAgICAgIGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwuc3RhcnRzV2l0aChcIi9cIikgJiZcbiAgICAgICAgIWJsdXJDb21wbGV0ZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRTaXplOiBzdHlsZT8ub2JqZWN0Rml0IHx8IFwiY292ZXJcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogc3R5bGU/Lm9iamVjdFBvc2l0aW9uIHx8IFwiNTAlIDUwJVwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybChcIiR7YXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTH1cIilgLFxuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgIGxldCBfc3JjID0gaXNTdGF0aWNJbWFnZSA/IHNyYy5zcmMgOiBzcmM7XG4gICAgaWYgKGJhc2VQYXRoICYmICFpc1N0YXRpY0ltYWdlICYmIF9zcmMuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgX3NyYyA9IGJhc2VQYXRoICsgX3NyYztcbiAgICB9XG4gICAgaWYgKGJhc2VQYXRoICYmICFpc1N0YXRpY0ltYWdlICYmICFfc3JjLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIF9zcmMgPSBiYXNlUGF0aCArIFwiL1wiICsgX3NyYztcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEltYWdlLCB7IHJlZjogcmVmLCBhbHQ6IGFsdCwgLi4ucmVzdCwgLi4uKHdpZHRoICYmIHsgd2lkdGggfSksIC4uLihoZWlnaHQgJiYgeyBoZWlnaHQgfSksIC4uLihsb2FkaW5nICYmIHsgbG9hZGluZyB9KSwgLi4uKGNsYXNzTmFtZSAmJiB7IGNsYXNzTmFtZSB9KSwgLi4uKG9uTG9hZCAmJiB7IG9uTG9hZCB9KSwgLi4uKG92ZXJyaWRlU3JjICYmIHsgb3ZlcnJpZGVTcmMgfSksIC4uLihwbGFjZWhvbGRlciAmJiB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogYmx1clN0eWxlIHx8IGJsdXJDb21wbGV0ZSA/IFwiZW1wdHlcIiA6IHBsYWNlaG9sZGVyLFxuICAgICAgICB9KSwgLi4uKHVub3B0aW1pemVkICYmIHsgdW5vcHRpbWl6ZWQgfSksIC4uLihwcmlvcml0eSAmJiB7IHByaW9yaXR5IH0pLCAuLi4oaXNTVkcgJiYgeyB1bm9wdGltaXplZDogdHJ1ZSB9KSwgc3R5bGU6IHsgLi4uc3R5bGUsIC4uLmJsdXJTdHlsZSB9LCBsb2FkZXI6IGltYWdlRXJyb3IgfHwgdW5vcHRpbWl6ZWQgPT09IHRydWVcbiAgICAgICAgICAgID8gKCkgPT4gZmFsbGJhY2tMb2FkZXIoeyBzcmM6IG92ZXJyaWRlU3JjIHx8IHNyYyB9KVxuICAgICAgICAgICAgOiAoZSkgPT4gb3B0aW1pemVkTG9hZGVyKHsgc3JjLCB3aWR0aDogZS53aWR0aCwgYmFzZVBhdGggfSksIGJsdXJEYXRhVVJMOiBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMLCBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHNldEltYWdlRXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBvbkVycm9yIGZ1bmN0aW9uIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9LCBvbkxvYWQ6IChlKSA9PiB7XG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjb25maWd1cmF0aW9ucywgdGhlIG9uRXJyb3IgaGFuZGxlciBpcyBub3QgY2FsbGVkIG9uIGFuIGVycm9yIG9jY3VycmVuY2VcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGltYWdlIGlzIGxvYWRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5uYXR1cmFsV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBCcm9rZW4gaW1hZ2UsIGZhbGwgYmFjayB0byB1bm9wdGltaXplZCAobWVhbmluZyB0aGUgb3JpZ2luYWwgaW1hZ2Ugc3JjKVxuICAgICAgICAgICAgICAgIHNldEltYWdlRXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBvbkxvYWQgY2FsbGJhY2sgaWYgcHJlc2VudFxuICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChlKTtcbiAgICAgICAgfSwgc3JjOiBpc1N0YXRpY0ltYWdlID8gc3JjIDogX3NyYyB9KSk7XG59KTtcbkV4cG9ydGVkSW1hZ2UuZGlzcGxheU5hbWUgPSBcIkV4cG9ydGVkSW1hZ2VcIjtcbmV4cG9ydCBkZWZhdWx0IEV4cG9ydGVkSW1hZ2U7XG4iXSwibmFtZXMiOlsiX2V4Y2x1ZGVkIiwib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIl90eXBlb2YiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImkiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic291cmNlS2V5cyIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsIml0ZXIiLCJpdGVyYXRvciIsImlzQXJyYXkiLCJsZW4iLCJhcnIyIiwiSW1hZ2UiLCJSZWFjdCIsImZvcndhcmRSZWYiLCJ1c2VNZW1vIiwidXNlU3RhdGUiLCJzcGxpdEZpbGVQYXRoIiwiX3JlZiIsIl9maWxlUGF0aCRzcGxpdCRwb3AiLCJmaWxlUGF0aCIsImZpbGVuYW1lV2l0aEV4dGVuc2lvbiIsInNwbGl0IiwicG9wIiwiZmlsZVBhdGhXaXRob3V0RmlsZW5hbWUiLCJzaGlmdCIsImZpbGVFeHRlbnNpb24iLCJmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24iLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsInBhdGgiLCJmaWxlbmFtZSIsImV4dGVuc2lvbiIsImdlbmVyYXRlSW1hZ2VVUkwiLCJzcmMiLCJ3aWR0aCIsImJhc2VQYXRoIiwiX2NvcnJlY3RlZFBhdGgiLCJpc1JlbW90ZUltYWdlIiwiX3NwbGl0RmlsZVBhdGgiLCJ1c2VXZWJwIiwicHJvY2VzcyIsImVudiIsIm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9zdG9yZVBpY3R1cmVzSW5XRUJQIiwiaW5jbHVkZXMiLCJ0b1VwcGVyQ2FzZSIsInByb2Nlc3NlZEV4dGVuc2lvbiIsImNvcnJlY3RlZFBhdGgiLCJsYXN0Q2hhciIsInN1YnN0ciIsImlzU3RhdGljSW1hZ2UiLCJlbmRzV2l0aCIsInN0YXJ0c1dpdGgiLCJleHBvcnRGb2xkZXJOYW1lIiwibmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX2V4cG9ydEZvbGRlck5hbWUiLCJiYXNlUGF0aFByZWZpeEZvclN0YXRpY0ltYWdlcyIsImdlbmVyYXRlZEltYWdlVVJMIiwiY29uY2F0IiwiY2hhckF0IiwiaGFzaEFsZ29yaXRobSIsInN0ciIsInNlZWQiLCJoMSIsImgyIiwiY2giLCJjaGFyQ29kZUF0IiwiTWF0aCIsImltdWwiLCJ1cmxUb0ZpbGVuYW1lIiwidXJsIiwicGFyc2VkVXJsIiwiVVJMIiwicGF0aG5hbWUiLCJlcnJvciIsImNvbnNvbGUiLCJpbWFnZVVSTEZvclJlbW90ZUltYWdlIiwiX3JlZjIiLCJlbmNvZGVkU3JjIiwib3B0aW1pemVkTG9hZGVyIiwiX3JlZjMiLCJfc3JjIiwib3JpZ2luYWxJbWFnZVdpZHRoIiwiX3Byb2Nlc3MkZW52JF9fTkVYVF9JIiwiX3Byb2Nlc3MkZW52JF9fTkVYVF9JMiIsImRldmljZVNpemVzIiwiX19ORVhUX0lNQUdFX09QVFMiLCJtYXAiLCJpbWFnZVNpemVzIiwiYWxsU2l6ZXMiLCJ2IiwiYSIsInNvcnQiLCJiIiwibmV4dExhcmdlc3RTaXplIiwiZmFsbGJhY2tMb2FkZXIiLCJfcmVmNCIsIkV4cG9ydGVkSW1hZ2UiLCJfcmVmNSIsInJlZiIsIl9yZWY1JHByaW9yaXR5IiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0Iiwib25Mb2FkIiwidW5vcHRpbWl6ZWQiLCJfcmVmNSRwbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyIiwiX3JlZjUkYmFzZVBhdGgiLCJfcmVmNSRhbHQiLCJhbHQiLCJibHVyRGF0YVVSTCIsInN0eWxlIiwib25FcnJvciIsIm92ZXJyaWRlU3JjIiwicmVzdCIsIl91c2VTdGF0ZSIsImltYWdlRXJyb3IiLCJzZXRJbWFnZUVycm9yIiwiYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTCIsImlzU1ZHIiwiX3VzZVN0YXRlMiIsImJsdXJDb21wbGV0ZSIsInNldEJsdXJDb21wbGV0ZSIsImJsdXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwib2JqZWN0Rml0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwib2JqZWN0UG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZEltYWdlIiwiY3JlYXRlRWxlbWVudCIsImxvYWRlciIsIm5hdHVyYWxXaWR0aCIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/workspaces/bidvid-website/node_modules/next-image-export-optimizer/dist/ExportedImage.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/workspaces/bidvid-website/node_modules/next-image-export-optimizer/dist/ExportedImage.js#default`));


/***/ })

};
;